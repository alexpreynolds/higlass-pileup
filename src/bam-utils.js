export const ASSEMBLY_ATTR_HG38 = [
  { refName: 'chr1', length: 248956422 },
  { refName: 'chr2', length: 242193529 },
  { refName: 'chr3', length: 198295559 },
  { refName: 'chr4', length: 190214555 },
  { refName: 'chr5', length: 181538259 },
  { refName: 'chr6', length: 170805979 },
  { refName: 'chr7', length: 159345973 },
  { refName: 'chr8', length: 145138636 },
  { refName: 'chr9', length: 138394717 },
  { refName: 'chr10', length: 133797422 },
  { refName: 'chr11', length: 135086622 },
  { refName: 'chr12', length: 133275309 },
  { refName: 'chr13', length: 114364328 },
  { refName: 'chr14', length: 107043718 },
  { refName: 'chr15', length: 101991189 },
  { refName: 'chr16', length: 90338345 },
  { refName: 'chr17', length: 83257441 },
  { refName: 'chr18', length: 80373285 },
  { refName: 'chr19', length: 58617616 },
  { refName: 'chr20', length: 64444167 },
  { refName: 'chr21', length: 46709983 },
  { refName: 'chr22', length: 50818468 },
  { refName: 'chrX', length: 156040895 },
  { refName: 'chrY', length: 57227415 },
  { refName: 'chrM', length: 16569 },
  { refName: 'GL000008.2', length: 209709 },
  { refName: 'GL000009.2', length: 201709 },
  { refName: 'GL000194.1', length: 191469 },
  { refName: 'GL000195.1', length: 182896 },
  { refName: 'GL000205.2', length: 185591 },
  { refName: 'GL000208.1', length: 92689 },
  { refName: 'GL000213.1', length: 164239 },
  { refName: 'GL000214.1', length: 137718 },
  { refName: 'GL000216.2', length: 176608 },
  { refName: 'GL000218.1', length: 161147 },
  { refName: 'GL000219.1', length: 179198 },
  { refName: 'GL000220.1', length: 161802 },
  { refName: 'GL000221.1', length: 155397 },
  { refName: 'GL000224.1', length: 179693 },
  { refName: 'GL000225.1', length: 211173 },
  { refName: 'GL000226.1', length: 15008 },
  { refName: 'KI270302.1', length: 2274 },
  { refName: 'KI270303.1', length: 1942 },
  { refName: 'KI270304.1', length: 2165 },
  { refName: 'KI270305.1', length: 1472 },
  { refName: 'KI270310.1', length: 1201 },
  { refName: 'KI270311.1', length: 12399 },
  { refName: 'KI270312.1', length: 998 },
  { refName: 'KI270315.1', length: 2276 },
  { refName: 'KI270316.1', length: 1444 },
  { refName: 'KI270317.1', length: 37690 },
  { refName: 'KI270320.1', length: 4416 },
  { refName: 'KI270322.1', length: 21476 },
  { refName: 'KI270329.1', length: 1040 },
  { refName: 'KI270330.1', length: 1652 },
  { refName: 'KI270333.1', length: 2699 },
  { refName: 'KI270334.1', length: 1368 },
  { refName: 'KI270335.1', length: 1048 },
  { refName: 'KI270336.1', length: 1026 },
  { refName: 'KI270337.1', length: 1121 },
  { refName: 'KI270338.1', length: 1428 },
  { refName: 'KI270340.1', length: 1428 },
  { refName: 'KI270362.1', length: 3530 },
  { refName: 'KI270363.1', length: 1803 },
  { refName: 'KI270364.1', length: 2855 },
  { refName: 'KI270366.1', length: 8320 },
  { refName: 'KI270371.1', length: 2805 },
  { refName: 'KI270372.1', length: 1650 },
  { refName: 'KI270373.1', length: 1451 },
  { refName: 'KI270374.1', length: 2656 },
  { refName: 'KI270375.1', length: 2378 },
  { refName: 'KI270376.1', length: 1136 },
  { refName: 'KI270378.1', length: 1048 },
  { refName: 'KI270379.1', length: 1045 },
  { refName: 'KI270381.1', length: 1930 },
  { refName: 'KI270382.1', length: 4215 },
  { refName: 'KI270383.1', length: 1750 },
  { refName: 'KI270384.1', length: 1658 },
  { refName: 'KI270385.1', length: 990 },
  { refName: 'KI270386.1', length: 1788 },
  { refName: 'KI270387.1', length: 1537 },
  { refName: 'KI270388.1', length: 1216 },
  { refName: 'KI270389.1', length: 1298 },
  { refName: 'KI270390.1', length: 2387 },
  { refName: 'KI270391.1', length: 1484 },
  { refName: 'KI270392.1', length: 971 },
  { refName: 'KI270393.1', length: 1308 },
  { refName: 'KI270394.1', length: 970 },
  { refName: 'KI270395.1', length: 1143 },
  { refName: 'KI270396.1', length: 1880 },
  { refName: 'KI270411.1', length: 2646 },
  { refName: 'KI270412.1', length: 1179 },
  { refName: 'KI270414.1', length: 2489 },
  { refName: 'KI270417.1', length: 2043 },
  { refName: 'KI270418.1', length: 2145 },
  { refName: 'KI270419.1', length: 1029 },
  { refName: 'KI270420.1', length: 2321 },
  { refName: 'KI270422.1', length: 1445 },
  { refName: 'KI270423.1', length: 981 },
  { refName: 'KI270424.1', length: 2140 },
  { refName: 'KI270425.1', length: 1884 },
  { refName: 'KI270429.1', length: 1361 },
  { refName: 'KI270435.1', length: 92983 },
  { refName: 'KI270438.1', length: 112505 },
  { refName: 'KI270442.1', length: 392061 },
  { refName: 'KI270448.1', length: 7992 },
  { refName: 'KI270465.1', length: 1774 },
  { refName: 'KI270466.1', length: 1233 },
  { refName: 'KI270467.1', length: 3920 },
  { refName: 'KI270468.1', length: 4055 },
  { refName: 'KI270507.1', length: 5353 },
  { refName: 'KI270508.1', length: 1951 },
  { refName: 'KI270509.1', length: 2318 },
  { refName: 'KI270510.1', length: 2415 },
  { refName: 'KI270511.1', length: 8127 },
  { refName: 'KI270512.1', length: 22689 },
  { refName: 'KI270515.1', length: 6361 },
  { refName: 'KI270516.1', length: 1300 },
  { refName: 'KI270517.1', length: 3253 },
  { refName: 'KI270518.1', length: 2186 },
  { refName: 'KI270519.1', length: 138126 },
  { refName: 'KI270521.1', length: 7642 },
  { refName: 'KI270522.1', length: 5674 },
  { refName: 'KI270528.1', length: 2983 },
  { refName: 'KI270529.1', length: 1899 },
  { refName: 'KI270530.1', length: 2168 },
  { refName: 'KI270538.1', length: 91309 },
  { refName: 'KI270539.1', length: 993 },
  { refName: 'KI270544.1', length: 1202 },
  { refName: 'KI270548.1', length: 1599 },
  { refName: 'KI270579.1', length: 31033 },
  { refName: 'KI270580.1', length: 1553 },
  { refName: 'KI270581.1', length: 7046 },
  { refName: 'KI270582.1', length: 6504 },
  { refName: 'KI270583.1', length: 1400 },
  { refName: 'KI270584.1', length: 4513 },
  { refName: 'KI270587.1', length: 2969 },
  { refName: 'KI270588.1', length: 6158 },
  { refName: 'KI270589.1', length: 44474 },
  { refName: 'KI270590.1', length: 4685 },
  { refName: 'KI270591.1', length: 5796 },
  { refName: 'KI270593.1', length: 3041 },
  { refName: 'KI270706.1', length: 175055 },
  { refName: 'KI270707.1', length: 32032 },
  { refName: 'KI270708.1', length: 127682 },
  { refName: 'KI270709.1', length: 66860 },
  { refName: 'KI270710.1', length: 40176 },
  { refName: 'KI270711.1', length: 42210 },
  { refName: 'KI270712.1', length: 176043 },
  { refName: 'KI270713.1', length: 40745 },
  { refName: 'KI270714.1', length: 41717 },
  { refName: 'KI270715.1', length: 161471 },
  { refName: 'KI270716.1', length: 153799 },
  { refName: 'KI270717.1', length: 40062 },
  { refName: 'KI270718.1', length: 38054 },
  { refName: 'KI270719.1', length: 176845 },
  { refName: 'KI270720.1', length: 39050 },
  { refName: 'KI270721.1', length: 100316 },
  { refName: 'KI270722.1', length: 194050 },
  { refName: 'KI270723.1', length: 38115 },
  { refName: 'KI270724.1', length: 39555 },
  { refName: 'KI270725.1', length: 172810 },
  { refName: 'KI270726.1', length: 43739 },
  { refName: 'KI270727.1', length: 448248 },
  { refName: 'KI270728.1', length: 1872759 },
  { refName: 'KI270729.1', length: 280839 },
  { refName: 'KI270730.1', length: 112551 },
  { refName: 'KI270731.1', length: 150754 },
  { refName: 'KI270732.1', length: 41543 },
  { refName: 'KI270733.1', length: 179772 },
  { refName: 'KI270734.1', length: 165050 },
  { refName: 'KI270735.1', length: 42811 },
  { refName: 'KI270736.1', length: 181920 },
  { refName: 'KI270737.1', length: 103838 },
  { refName: 'KI270738.1', length: 99375 },
  { refName: 'KI270739.1', length: 73985 },
  { refName: 'KI270740.1', length: 37240 },
  { refName: 'KI270741.1', length: 157432 },
  { refName: 'KI270742.1', length: 186739 },
  { refName: 'KI270743.1', length: 210658 },
  { refName: 'KI270744.1', length: 168472 },
  { refName: 'KI270745.1', length: 41891 },
  { refName: 'KI270746.1', length: 66486 },
  { refName: 'KI270747.1', length: 198735 },
  { refName: 'KI270748.1', length: 93321 },
  { refName: 'KI270749.1', length: 158759 },
  { refName: 'KI270750.1', length: 148850 },
  { refName: 'KI270751.1', length: 150742 },
  { refName: 'KI270752.1', length: 27745 },
  { refName: 'KI270753.1', length: 62944 },
  { refName: 'KI270754.1', length: 40191 },
  { refName: 'KI270755.1', length: 36723 },
  { refName: 'KI270756.1', length: 79590 },
  { refName: 'KI270757.1', length: 71251 },
];

export const PILEUP_COLORS = {
  BG: [0.89, 0.89, 0.89, 1], // gray for the read background
  BG2: [0.85, 0.85, 0.85, 1], // used as alternating color in the read counter band
  BG_MUTED: [0.92, 0.92, 0.92, 1], // coverage background, when it is not exact
  A: [0, 0, 1, 1], // blue for A
  C: [1, 0, 0, 1], // red for c
  G: [0, 1, 0, 1], // green for g
  T: [1, 1, 0, 1], // yellow for T
  S: [0, 0, 0, 0.4], // lighter grey for soft clipping
  H: [0, 0, 0, 0.5], // darker grey for hard clipping
  X: [0, 0, 0, 0.7], // black for unknown
  I: [1, 0, 1, 0.5], // purple for insertions
  D: [1, 0.5, 0.5, 0.5], // pink-ish for deletions
  N: [1, 1, 1, 1],
  LARGE_INSERT_SIZE: [1, 0, 0, 1], // Red for read pairs with large insert size
  SMALL_INSERT_SIZE: [0, 0.24, 0.48, 1], // Dark blue for read pairs with small insert size
  LL: [0.15, 0.75, 0.75, 1], // cyan for Left-Left reads (see https://software.broadinstitute.org/software/igv/interpreting_pair_orientations)
  RR: [0.18, 0.24, 0.8, 1], // darker blue for Right-Right reads
  RL: [0, 0.5, 0.02, 1], // darker green for Right-Left reads
  WHITE: [1, 1, 1, 1],
  BLACK: [0, 0, 0, 1],
  BLACK_05: [0, 0, 0, 0.5],
  PLUS_STRAND: [0.75, 0.75, 1, 1],
  MINUS_STRAND: [1, 0.75, 0.75, 1],
  MM_M6A_FOR: [0.4, 0.2, 0.6, 1], // purple for m6A methylation events
  MM_M6A_REV: [0.4, 0.2, 0.6, 1], // purple for m6A methylation events
  MM_M5C_FOR: [1, 0, 0, 1], // red for CpG events
  MM_M5C_REV: [1, 0, 0, 1], // red for CpG events
  MM_HM5C_FOR: [1, 0.6, 0.2, 1], // purple for 5hmC events
  MM_HM5C_REV: [1, 0.6, 0.2, 1], // purple for 5hmC events
  HIGHLIGHTS_CG: [0.95, 0.84, 0.84, 1], // CG highlights
  HIGHLIGHTS_A: [0.95, 0.89, 0.71, 1], // A highlights
  HIGHLIGHTS_T: [0.95, 0.89, 0.71, 1], // T highlights
  HIGHLIGHTS_G: [0.95, 0.84, 0.84, 1], // G highlights
  HIGHLIGHTS_C: [0.95, 0.84, 0.84, 1], // C highlights
  HIGHLIGHTS_MZEROA: [0.89, 0.84, 0.96, 1], // m0A highlights
  INDEX_DHS_BG: [0, 0, 0, 0],
  FIRE_SEGMENT_BG: [0, 0, 0, 0],
  FIRE_BG: [0.88, 0.88, 0.88, 1],
  TFBS_SEGMENT_BG: [0, 0, 0, 1],
  TFBS_BG: [1, 1, 1, 1],
  GENERIC_BED_SEGMENT_BG: [0, 0, 0, 1],
  GENERIC_BED_SEGMENT_RED_BG: [1, 0, 0, 1],
  "FIRE_169,169,169": [0.66, 0.66, 0.66],
  "FIRE_147,112,219": [0.58, 0.44, 0.86],
  "FIRE_255,0,0": [1, 0, 0],
  "FIRE_200,0,0": [0.78, 0, 0],
  "FIRE_255,140,0": [1, 0.55, 0],
  "FIRE_175,0,0": [0.68, 0, 0],
  "FIRE_225,0,0": [0.88, 0, 0],
  "FIRE_139,0,0": [0.54, 0, 0],
};

export let PILEUP_COLOR_IXS = {};
Object.keys(PILEUP_COLORS).map((x, i) => {
  PILEUP_COLOR_IXS[x] = i;
  return null;
});

export function replaceColorIdxs(newColorIdxs) {
  PILEUP_COLOR_IXS = newColorIdxs;
}

export function appendColorIdxs(newColorIdxs) {
  const currentColorTableLength = Object.keys(PILEUP_COLOR_IXS).length;
  Object.keys(newColorIdxs).map((x, i) => { newColorIdxs[x] = i + currentColorTableLength; })
  PILEUP_COLOR_IXS = {...PILEUP_COLOR_IXS, ...newColorIdxs};
}

export const hexToRGBRawTriplet = (hex) => {
  hex = hex.toUpperCase();
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `${r},${g},${b}`;
}

export const genericBedColors = (options) => {
  if (!options.genericBed) return {};
  const colorTable = {};
  colorTable['GENERIC_BED_BG'] = [0, 0, 0, 0], // Generic BED background default
  // Object.entries(options.genericBed.colors).map((o) => {
  //   const c = o[0];
  //   console.log(`c ${c}`);
  //   const v = c.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
  //   colorTable[`GENERIC_BED_${c}`] = [...v, 1.0];
  // });
  options.genericBed.colors.forEach((c, i) => {
    // console.log(`c ${c} | i ${i}`);
    const v = c.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`GENERIC_BED_${c}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify({...PILEUP_COLORS, ...colorTable})}`);
  return {...PILEUP_COLORS, ...colorTable};
}

export const indexDHSColors = (options) => {
  if (!options.indexDHS) return {};
  // console.log(`options ${JSON.stringify(options)}`);
  // console.log(`options.indexDHS.itemRGBMap ${JSON.stringify(options.indexDHS.itemRGBMap)}`);
  const colorTable = {};
  colorTable['INDEX_DHS_BG'] = [0, 0, 0, 0], // Index DHS background default
  Object.entries(options.indexDHS.itemRGBMap).map((o) => {
    const k = o[0];
    // const v = o[1];
    const v = k.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`INDEX_DHS_${k}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify(colorTable)}`);
  return {...PILEUP_COLORS, ...colorTable};
};

export const fireColors = (options) => {
  if (!options.fire) return {};
  // console.log(`options.fire ${JSON.stringify(options.fire)}`);
  const colorTable = {};
  colorTable['FIRE_BG_TEST'] = [0.89, 0.89, 0.89, 1], // FIRE background default
  Object.entries(options.fire.metadata.itemRGBMap).map((o) => {
    const k = o[0];
    // const v = o[1];
    const v = k.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`FIRE_${k}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify(colorTable)}`);
  return {...PILEUP_COLORS, ...colorTable};
};

export const cigarTypeToText = (type) => {
  if (type === 'D') {
    return 'Deletion';
  } else if (type === 'S') {
    return 'Soft clipping';
  } else if (type === 'H') {
    return 'Hard clipping';
  } else if (type === 'I') {
    return 'Insertion';
  } else if (type === 'N') {
    return 'Skipped region';
  }

  return type;
};

export const parseMD = (mdString, useCounts) => {
  let currPos = 0;
  let currNum = 0;
  let deletionEncountered = false;
  let bamSeqShift = 0;
  const substitutions = [];

  for (let i = 0; i < mdString.length; i++) {
    if (mdString[i].match(/[0-9]/g)) {
      // a number, keep on going
      currNum = currNum * 10 + +mdString[i];
      deletionEncountered = false;
    } else if (mdString[i] === '^') {
      deletionEncountered = true;
    } else {
      currPos += currNum;

      if (useCounts) {
        substitutions.push({
          length: currNum,
          type: mdString[i],
        });
      } else if (deletionEncountered) {
        // Do nothing if there is a deletion and keep on going.
        // Note that there can be multiple deletions "^ATC"
        // Deletions are visualized using the CIGAR string
        // However, keep track of where in the bam seq we need to pull the variant.
        bamSeqShift -= 1;
      } else {
        substitutions.push({
          pos: currPos,
          base: mdString[i],
          length: 1,
          bamSeqShift,
        });
      }

      currNum = 0;
      currPos += 1;
    }
  }

  return substitutions;
};

/**
 * Builds an array of all methylations in the segment, represented
 * as offsets from the 5' end of the sequence, using data available
 * in the read's MM and ML tags
 * 
 * ref. https://samtools.github.io/hts-specs/SAMtags.pdf
 * 
 * @param  {String} segment  Current segment
 * @param  {String} seq   Read sequence from bam file.
 * @param  {Boolean} alignCpGEvents  Align stranded CpG events at the methylation offset level.
 * @return {Array}  Methylation offsets.
 */
export const getMethylationOffsets = (segment, seq, alignCpGEvents) => {
  let methylationOffsets = [];
  const moSkeleton = {
    "unmodifiedBase" : "",
    "code" : "",
    "strand" : "",
    "offsets" : [],
    "probabilities" : [],
  };
  
  const getAllIndexes = (arr, val) => {
    let indices = [], i;
    for (let i = 0; i < arr.length; ++i) {
      if (arr[i] === val) {
        indices.push(i);
      }
    }
    return indices;
  }

  // include IUPAC degeneracies, to follow SAM specification
  const complementOf = {
    'A' : 'T',
    'C' : 'G', 
    'G' : 'C', 
    'T' : 'A',
    'U' : 'A',
    'Y' : 'R',
    'R' : 'Y',
    'S' : 'S',
    'W' : 'W', 
    'K' : 'M',
    'M' : 'K',
    'B' : 'V',
    'V' : 'B',
    'D' : 'H',
    'H' : 'D',
    'N' : 'N',
  };
  // const reverseComplementString = (str) => str.split('').reduce((reversed, character) => complementOf[character] + reversed, '');
  // const reverseString = (str) => str.split('').reduce((reversed, character) => character + reversed, '');

  // console.log(`segment.mm | ${JSON.stringify(segment.mm)}`);
  // console.log(`segment.ml | ${JSON.stringify(segment.ml)}`);

  if (segment.mm && segment.ml) {
    let currentOffsetCount = 0;
    const baseModifications = segment.mm.split(';');
    const baseProbabilities = segment.ml.split(',');
    baseModifications.forEach((bm) => {
      if (bm.length === 0) return;
      const mo = Object.assign({}, moSkeleton);
      const elems = bm.split(',');
      mo.unmodifiedBase = elems[0].charAt(0);
      mo.strand = elems[0].charAt(1);
      mo.code = elems[0].charAt(2);
      const nOffsets = elems.length - 1;
      const offsets = new Array(nOffsets);
      const probabilities = new Array(nOffsets);
      const baseIndices = (segment.strand === '+') ? getAllIndexes(seq, mo.unmodifiedBase) : getAllIndexes(seq, complementOf[mo.unmodifiedBase]);

      //
      // build initial list of raw offsets
      //
      let offset = 0;
      if (segment.strand === '+') {
        for (let i = 1; i < elems.length; ++i) {
          const d = parseInt(elems[i]);
          offset += d;
          const strandedOffset = offset;
          const baseOffset = baseIndices[strandedOffset];
          const baseProbability = baseProbabilities[i - 1 + currentOffsetCount];
          offsets[i - 1] = baseOffset;
          probabilities[i - 1] = baseProbability;
          offset += 1;
        }
      }
      else {
        for (let i = 1; i < elems.length; ++i) {
          const d = parseInt(elems[i]);
          offset += d;
          const strandedOffset = baseIndices.length - offset - 1;
          const baseOffset = baseIndices[strandedOffset];
          const baseProbability = baseProbabilities[i - 1 + currentOffsetCount];
          offsets[nOffsets - i] = baseOffset; // reverse
          probabilities[nOffsets - i] = baseProbability;
          offset += 1;
        }
      }

      //
      // shift reverse-stranded CpG events upstream by one bases
      //
      // console.log(`alignCpGEvents ${alignCpGEvents}`);
      // if (mo.unmodifiedBase === 'C' && segment.strand === '-' && alignCpGEvents) {
      //   for (let i = 0; i < nOffsets; ++i) {
      //     offsets[i] -= 1;
      //   }
      // }

      //
      // modify raw offsets with CIGAR/substitution data
      //
      let offsetIdx = 0;
      let offsetModifier = 0;
      let clipLength = 0;
      const modifiedOffsets = new Array();
      const modifiedProbabilities = new Array();

      for (const sub of segment.substitutions) {
        //
        // if the read starts or ends with soft or hard clipping
        //
        if ((sub.type === 'S') || (sub.type === 'H')) {
          offsetModifier -= sub.length;
          clipLength = sub.length;
        }
        //
        // walk through offsets and include those less than the current substitution position
        //
        else if ((sub.type === 'M') || (sub.type === '=')) {
          while ((offsets[offsetIdx] + offsetModifier) < (sub.pos + sub.length)) {
            if ((offsets[offsetIdx] + offsetModifier) >= sub.pos) {
              modifiedOffsets.push(offsets[offsetIdx] + offsetModifier - clipLength);
              modifiedProbabilities.push(probabilities[offsetIdx]);
            }
            offsetIdx++;
          }
        }
        //
        // filter out mismatches, else modify the offset padding
        //
        else if (sub.type === 'X') {
          if ((offsets[offsetIdx] + offsetModifier) === sub.pos) {
            offsetIdx++;
          }
        }
        //
        // handle substitution operations
        //
        else if (sub.type === 'D') {
          offsetModifier += sub.length;
        }
        else if (sub.type === 'I') {
          offsetModifier -= sub.length;
        }
        else if (sub.type === 'N') {
          offsetModifier += sub.length;
        }
        //
        // if the read ends with soft or hard clipping
        //
        if ((sub.type === 'S') || (sub.type === 'H')) {
          offsetModifier += sub.length;
        }
      };

      mo.offsets = modifiedOffsets;
      mo.probabilities = modifiedProbabilities;

      // if (mo.unmodifiedBase === 'A') {
      //   console.log(`segment.substitutions ${JSON.stringify(segment.substitutions, null, 2)}`); 
      //   console.log(`${JSON.stringify(actions)}`);
      // }
      
      methylationOffsets.push(mo);
      currentOffsetCount += nOffsets;
    });
  }

  // console.log(`methylationOffsets ${JSON.stringify(methylationOffsets, null, 2)}`);

  return methylationOffsets;
}

/**
 * Gets an array of all substitutions in the segment
 * @param  {String} segment  Current segment
 * @param  {String} seq   Read sequence from bam file.
 * @return {Boolean} includeClippingOps  Include soft or hard clipping operations in substitutions output.
 */
export const getSubstitutions = (segment, seq, includeClippingOps) => {
  let substitutions = [];
  let softClippingAtReadStart = null;

  if (segment.cigar) {
    const cigarSubs = parseMD(segment.cigar, true);

    let currPos = 0;

    for (const sub of cigarSubs) {
      if (includeClippingOps && ((sub.type === 'S') || (sub.type === 'H'))) {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: sub.type,
        });
        currPos += sub.length;
      }
      else if (sub.type === 'X') {
        // sequence mismatch, no need to do anything
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'X',
        });
        currPos += sub.length;
      } 
      else if (sub.type === 'I') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'I',
        });
        // currPos -= sub.length;
      } 
      else if (sub.type === 'D') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'D',
        });
        currPos += sub.length;
      } 
      else if (sub.type === 'N') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'N',
        });
        currPos += sub.length;
      } 
      else if (sub.type === '=') { 
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: '=',
        });
        currPos += sub.length;
      } 
      else if (sub.type === 'M') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'M',
        });
        currPos += sub.length;
      }
      else {
        // console.log('skipping:', sub.type);
      }
    }

    const firstSub = cigarSubs[0];
    const lastSub = cigarSubs[cigarSubs.length - 1];

    // Soft clipping can happen at the beginning, at the end or both
    // positions are from the beginning of the read
    if (firstSub.type === 'S') {
      softClippingAtReadStart = firstSub;
      // soft clipping at the beginning
      substitutions.push({
        pos: -firstSub.length,
        type: 'S',
        length: firstSub.length,
      });
    }
    // soft clipping at the end
    if (lastSub.type === 'S') {
      substitutions.push({
        pos: segment.to - segment.from,
        length: lastSub.length,
        type: 'S',
      });
    }

    // Hard clipping can happen at the beginning, at the end or both
    // positions are from the beginning of the read
    if (firstSub.type === 'H') {
      substitutions.push({
        pos: -firstSub.length,
        type: 'H',
        length: firstSub.length,
      });
    }
    if (lastSub.type === 'H') {
      substitutions.push({
        pos: segment.to - segment.from,
        length: lastSub.length,
        type: 'H',
      });
    }
  }

  if (segment.md) {
    const mdSubstitutions = parseMD(segment.md, false);

    mdSubstitutions.forEach(function (substitution) {
      let posStart = substitution['pos'] + substitution['bamSeqShift'];
      let posEnd = posStart + substitution['length'];
      // When there is soft clipping at the beginning,
      // we need to shift the position where we read the variant from the sequence
      // not necessary when there is hard clipping
      if (softClippingAtReadStart !== null) {
        posStart += softClippingAtReadStart.length;
        posEnd += softClippingAtReadStart.length;
      }
      substitution['variant'] = seq.substring(posStart, posEnd);
      delete substitution['bamSeqShift'];
    });

    substitutions = mdSubstitutions.concat(substitutions);
  }

  return substitutions;
};

/**
 * Checks the track options and determines if mates need to be loaded
 */
export const areMatesRequired = (trackOptions) => {
  return (
    trackOptions.highlightReadsBy.length > 0 ||
    trackOptions.outlineMateOnHover
  );
};

/**
 * Calculates insert size between read segements
 */
 export const calculateInsertSize = (segment1, segment2) => {
  return segment1.from < segment2.from
    ? Math.max(0, segment2.from - segment1.to)
    : Math.max(0, segment1.from - segment2.to);
};